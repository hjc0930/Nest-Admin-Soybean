# 加密安全分析报告

## 当前实现分析

### 加密流程
1. 前端获取RSA公钥（`GET /auth/publicKey`）
2. 前端生成随机AES密钥
3. 前端使用RSA公钥加密AES密钥 → `encryptedKey`
4. 前端使用AES密钥加密请求数据 → `encryptedData`
5. 前端发送 `{ encryptedKey, encryptedData }` 到后端
6. 后端使用RSA私钥解密 `encryptedKey` 得到AES密钥
7. 后端使用AES密钥解密 `encryptedData` 得到原始数据

### 存在的安全问题

#### 1. 公钥公开问题 ✅ 正常
- **问题描述**：公钥是公开的，任何人都可以获取
- **评估**：这是RSA加密的正常设计，公钥本身就是用来公开的
- **风险等级**：✅ 无风险（符合设计）

#### 2. 可以自己生成AES密钥 ⚠️ 中等风险
- **问题描述**：攻击者可以：
  1. 获取公钥（公开的）
  2. 自己生成AES密钥
  3. 用公钥加密AES密钥
  4. 用AES密钥加密任意数据
  5. 发送伪造请求
- **风险等级**：⚠️ 中等风险
- **影响**：可以伪造请求，但需要配合其他安全措施（如JWT token、权限校验等）

#### 3. 缺少一次一密机制 ⚠️ 中等风险
- **问题描述**：
  - 虽然每次请求都生成新的AES密钥，但没有nonce（随机数）机制
  - 没有时间戳校验
  - 无法确保每次请求的唯一性
- **风险等级**：⚠️ 中等风险
- **影响**：无法防止重放攻击

#### 4. 缺少防重放攻击机制 🔴 高风险
- **问题描述**：
  1. 攻击者拦截一次请求，获取 `encryptedKey` 和 `encryptedData`
  2. 由于有RSA私钥（或通过其他方式），可以解密得到AES密钥
  3. 之后可以重复使用这个AES密钥发送相同的请求（重放攻击）
  4. 即使每次生成新的AES密钥，如果攻击者能解密一次，就可以重放该请求
- **风险等级**：🔴 高风险
- **影响**：可以重放之前的请求，可能导致：
  - 重复执行操作（如重复转账、重复下单等）
  - 绕过时间限制
  - 绕过业务逻辑校验

## 改进方案

### 方案1：添加Nonce机制（推荐）

#### 实现思路
1. 每次请求生成唯一的nonce（随机数）
2. 将nonce包含在加密数据中
3. 后端维护nonce缓存（如Redis），检查nonce是否已使用
4. 如果nonce已使用，拒绝请求

#### 优点
- 简单有效
- 可以防止重放攻击
- 实现成本低

#### 缺点
- 需要额外的存储（Redis）
- 需要定期清理过期的nonce

### 方案2：添加时间戳校验

#### 实现思路
1. 每次请求包含时间戳
2. 后端校验时间戳，拒绝过期的请求（如5分钟内）
3. 结合nonce机制，确保唯一性

#### 优点
- 可以防止过期请求的重放
- 实现简单

#### 缺点
- 需要时钟同步
- 无法防止时间窗口内的重放

### 方案3：请求签名机制

#### 实现思路
1. 在加密数据中包含请求签名
2. 签名 = HMAC(请求数据 + 时间戳 + nonce, 共享密钥)
3. 后端验证签名

#### 优点
- 安全性高
- 可以防止篡改

#### 缺点
- 需要共享密钥管理
- 实现复杂度较高

### 方案4：结合JWT Token

#### 实现思路
1. 在加密数据中包含JWT token
2. JWT token中包含nonce和时间戳
3. 后端验证JWT token的有效性和唯一性

#### 优点
- 可以复用现有的认证机制
- 安全性高

#### 缺点
- 需要修改现有认证流程
- 实现复杂度较高

## 推荐实施方案

### 阶段1：基础防重放（✅ 已实施）
1. **添加Nonce机制** ✅
   - 前端：每次请求生成UUID作为nonce（`globalThis.crypto.randomUUID()`）
   - 后端：使用Redis存储nonce，TTL=5分钟
   - 后端：检查nonce是否已使用，已使用则拒绝（抛出BadRequestException）

2. **添加时间戳校验** ✅
   - 前端：在加密数据中包含时间戳（`Date.now()`）
   - 后端：校验时间戳，拒绝超过5分钟的请求（允许±5分钟偏差）

### 实现细节

#### 前端实现
- 文件：`admin-naive-ui/src/service/request/index.ts`
- 在`handleEncrypt`函数中：
  - 生成nonce：`globalThis.crypto.randomUUID()`
  - 生成时间戳：`Date.now()`
  - 将nonce和时间戳添加到请求数据中（`_nonce`和`_timestamp`字段）
  - 一起加密发送到后端

#### 后端实现
- 文件：`server/src/security/crypto/crypto.service.ts`
- `decryptRequest`方法：
  1. 解密请求数据
  2. 提取`_nonce`和`_timestamp`字段
  3. 校验时间戳是否在允许范围内（±5分钟）
  4. 校验nonce是否已使用（Redis检查）
  5. 如果nonce未使用，存储到Redis（TTL=5分钟）
  6. 从解密数据中移除`_nonce`和`_timestamp`字段
  7. 返回清理后的数据

- 文件：`server/src/security/crypto/crypto.interceptor.ts`
- `DecryptInterceptor`拦截器：
  - 支持异步解密和校验
  - 处理BadRequestException异常

#### 配置参数
- `NONCE_TTL`: 5分钟（300,000毫秒）
- `TIMESTAMP_TOLERANCE`: 5分钟（300,000毫秒）

### 阶段2：增强安全性（后续优化）
1. **请求签名**
   - 在加密数据中包含HMAC签名
   - 使用客户端ID + 时间戳 + nonce生成签名

2. **Nonce与Session绑定**
   - 将nonce与用户session绑定
   - 防止跨用户重放

## 实施优先级

1. 🔴 **高优先级**：添加Nonce机制（防止重放攻击）
2. 🟡 **中优先级**：添加时间戳校验（防止过期请求）
3. 🟢 **低优先级**：请求签名机制（增强安全性）

## 注意事项

1. **当前加密的作用**：
   - ✅ 保护传输过程中的数据不被窃听（中间人攻击）
   - ✅ 防止明文传输敏感数据
   - ❌ 不能防止重放攻击（需要额外机制）
   - ❌ 不能防止请求伪造（需要配合认证机制）

2. **配合其他安全措施**：
   - JWT Token认证（防止未授权访问）
   - 权限校验（防止越权操作）
   - 业务逻辑校验（防止重复操作）
   - HTTPS（防止中间人攻击）

3. **性能考虑**：
   - Nonce存储使用Redis，TTL设置合理
   - 定期清理过期的nonce
   - 考虑使用布隆过滤器优化nonce检查
